GRA-EXT
=======

Autor: Johann Klasek, johann AT klasek at


Versionen:

	2016-07-13 v 1.27		&V geschwindigkeitsoptimiert.
	2016-07-09 v 1.26		Funktionen &X,&Y,&Z(x,y) ergänzt.
					save-Variablen umgeordnet, erweitert.
					Single-Expression-Hook ($030A) verwendet.
	2016-06-19 v 1.25		&C korrigiert umstrukturiert.
					&s5 ist noch nicht implementiert.
					Produktiv mit Mängel:
					Fehlerbehandlung korr. (für &s3-5)
					Neu: &H x,y,xl[,yl] (breite horiz.  Linie)
					LTC-Variante berücksichtigt spezielle
					Speicherkonfiguration!
					Versionsnummer im Dateikopf.
	2016-06-16 v 1.24		Bugfix: &C korrigiert umstrukturiert.
					Startmeldung nur im Direktmodus ausgeben.
					Buggy:
					&s3-5 funktioniert nicht.
					Fehlerbehandlung unvollständig (für &s3-5)
	2016-05-30 v 1.23		&U neu (UNNEW)
					Buggy:
					&s3-5 funktioniert nicht.
					Fehlerbehandlung unvollständig (für &s3-5)
	2016-05-20 v 1.22		&G Modi 3 (nur löschen) und 4 (nur aus)
					&S neue Werte 3-5 für Fehlerbehandlung,
					Fehlerbehandlung dynamisch (unvollständig)
					ROM-fähig (gmask, gchange Routinen ins
					RAM, $033C-Bereich)
					Buggy:
					&s3-5 funktioniert nicht.
					Fehlerbehandlung unvollständig (für &s3-5)
	2016-02-23 v 1.21		graext-core.asm als Basis für
					graext (ge) und ge-run (als
					RUN-Programm, verschiebt Basic-Start!)
	2016-02-23 v 1.20		Optimierte Jump-Table, Bugfix Line
					command_rts_style=1 ... Kommandoverteiler
					via RTS statt JMP.
					Bugfix Command-Hook: z.B. ":" am
					Zeilenanfang lösten einen Syntax-Error aus.
	2016-01-18 v 1.19               Bug in Line flat/up
					no_error=1 ... kein Illegal Quantity Error
	2016-01-14 v 1.18		in ACME-Source übertragen
					Binär dem Original 1992 entsprechend,
					inklusive aller Bugs.
	1992-12-28 v 1.18		Kommandosyntax ohne ","
					Verteils (z.B. an Michael Rautner)
	1986-03-24 v 1.17		Finale Version
					zur damaligen Zeit üblicherweise
					in Verwendung (Maturazeitungsdiagramme)
	1985       v 0.00 - 1.16


ToDo:

 behoben:
 * &C Prozport nicht mit festen Wert überschreiben ($21), nur maskieren! -> ab 1.24


Wunschliste:

 * Fill
 * Grafik löschen separat und besonders schnell!
 * Optimierungen: Line, zu niedrigen Koordinaten mit
        Dekremetieren und Zero-Bedingung statt Inkremtieren
        mit explizitem Vergleich.
 * Circle
 * Clipping: trotzdem Zeichnen, aber am Rand aufhören.
        Echtes Clipping oder nur Koordinaten abschneiden?
        (Fehlerbehandlung Mode 5!)
 * Multicolor?

erledigt:
 * Grafikcursor auslesen -> ab 1.26
 * GETXY-Funktion -> ab 1.26
 * Fehlerbehandlung auswählbar -> ab 1.25
 * Block gefüllt (&H anpassen?) -> ab 1.25
 * Unnew -> ab 1.23
 * Grafik einschalten ohne löschen. -> ab 1.22


Geschichte:

Die Wurzeln der Erweiterung liegen bei der Grafikerweiterung für die
Forth-Umgebung Performance Micro Prod. von Greg Harris. Die im (eigenen)
Forth-Assembler codierten Routinen sind dahingehend optimiert, dass die
auf dem Bresenham-Algorithmus basierende Umsetzung ohne ständige
Punktpositionsberechung arbeitet, sondern der Grafikcursor als Adresse
und Bitposition geführt wird.
Ein gleichwertige Implementierung findet man auch im Spiel Elite, wobei dort
der Grafikbereich so eingeschränkt ist, dass die X-Koordinate mit einem Byte
auskommt (0-255), was eine noch schnellere Implementierung erlaubt.
Dazu kamen auch noch speziell optimiert Varianten für eine horizontale
und vertikale Linie, die auch als Sonderfall beim gewöhnlichen Linienbefehl
Verwendung finden.

Eine Verwendung für BASIC war wegen der Akzeptanz dringend notwendig,
was zur Entwicklung einer entsprechenden BASIC-Erweiterung führte. Das
genaue Zustandekommen der Übertragung aus dem Forth-Code ist nicht mehr
nachvollziehbar, da entsprechende Aufzeichnung fehlen. Vermutet werden
kann, dass Code entweder 1:1 herauskopiert wurde und dabei mit
Hilfe eines Monitors der Code verschoben und dessen absoluten Referenzen
und Zeropage-Adressen automatisch angepasst wurden. Der Glue-Code für den
Basic-Interpreter wurde direkt mit einem Monitor assembliert und
schließlich ohne eigentlichem Sourcecode abgespeichert.
Oder es wurde ein Assembler-Source vom Forth-Source konvertiert und
dann mit dem Glue-Code versehen. Der Source-Code ist aber nicht mehr
auffindbar, der diese Variante hätte belegen können.

Dabei ist der Code für den Punkttest (unter Forth "TEST") zwar enthalten,
wird aber vom Glue-Code nicht in den Interpreter eingebunden.


Verwendung
----------


### RUN-Variante

LOAD"GE-RUN",8
RUN

# Einschaltmeldung sollte erscheinen.

LOAD"....",8



### SYS-Variante

LOAD"GE",8,1
NEW
LOAD"....",8

1 IFPEEK(49153)+PEEK(49154)=21THENSYS49152



### Originalvariante

LOAD"G-EXT18",8,1
NEW
LOAD"....",8

1 SYS49152




Source
------


Makefile		Erstellen von
			make
				erstellt Gra-Ext PRGs
			make i
				erstellt D64-Image x.d64

debug.bas		Grafik-Demo: Block-/Linien-Demo
				zum Experimentieren (Textformat)
debug.prg		Grafik-Demo: Block-/Linien-Demo
				zum Experimentieren (CBM-Format)

demo1.bas		Grafik-Demo: Schirm mit Linien füllen (Textformat)
demo1.prg		Grafik-Demo: Schirm mit Linien füllen (CBM-Format)

demo2.bas		Grafik-Demo: Schirm mit mittigem Linienstrahlen füllen (Textformat)
demo2.prg		Grafik-Demo: Schirm mit mittigem Linienstrahlen füllen (CBM-Format)

demo-h-v.bas		Grafik-Demo: Vergleich Schirmfüllen mit
			H-Linien, V-Linien und H-Block (Textformat)
demo-h-v.prg		Grafik-Demo: Vergleich Schirmfüllen mit
			H-Linien, V-Linien und H-Block (CBM-Format)

demo-v.bas		Grafik-Demo: Zeitmessung Schirmfüllen mit V-Linien (Textformat)
demo-v.prg		Grafik-Demo: Zeitmessung Schirmfüllen mit V-Linien (CBM-Format)

g-ext18.hex		Gra-Ext 1.8 im od-Hex-Format
g-ext18.prg		Gra-Ext 1.8 im CBM-Format als Referenz, von der
			Distributionsdisk

gliding-lines.bas	Grafik-Demo: Bewegendes Linienbündel (Textformat)
gliding-lines.prg	Grafik-Demo: Bewegendes Linienbündel (CBM-Format)

ge-run.asm		Gra-Ext RUN-Variante, verwendet graext-core.asm
ge-run.l		ACME Listing-Ausgabe der RUN-Variante
ge-run.prg		ACME Objekt-Datei (CBM-Format) der RUN-Variante
ge-run.r		ACME Report-Ausgabe der RUN-Variante

graext-c000-ltc		Gra-Ext LTC-Variante (Lost Turbo Card 64)
graext-c000-ltc.l	ACME Listing-Ausgabe der LTC-Variante
graext-c000-ltc.r	ACME Report-Ausgabe der LTC-Variante

graext-core.asm		Gra-Ext Core für RUN-Variante, SYS-Variante

graext.asm		Gra-Ext SYS-Variante, verwendet graext-core.asm

graext.hex		Binary im Hex-Format für den diff-Vergleich
			mit der Referenz g-ext18.hex
			War nur für die Source-Wiederherstellung
			auf Basis des 1.8-Codes verwendet worden.

ge.prg			Nur eine Kopie von graext.o, für das D64-Image

graext.l		ACME Listing-Ausgabe der SYS-Variante
graext.o		ACME Objekt-Datei (CBM-Format) der SYS-Variante
graext.r		ACME Report-Ausgabe der SYS-Variante

info.txt		diese Datei

x.d64			D64-Image, erstell mittels
			make x.d64
			oder
			make i



Lost Turbo Card 64 (LTC)
------------------------

Seit V 1.25 ist mit "graext-c000-ltc" die Unterstützung für die 65816-CPU-Erweiterungsplatine
auf Basis eines Artikels im c't-Magazin gegeben:

Michael Flamm, Rene Schneider:
Aufgemotzt
C64 mit 4-MHz-Takt und 16-Bit -CPU
Projekt, Commodore C64
c't 6/87, Seite 94ff

Im Boot-ROM der Erweiterung wird GraExt eingebunden und kann mit SYS 49152
aktiviert werden. Dies ist dank der seit Version 1.22 eingeführten
ROM-Fähigkeit bei GraExt nun möglich.
Dabei wird die vollständige ROM-Simulation aktiviert, die
gewährleistet, dass GraExt mit der vollen Taktfrequenz (nicht auf 1 MHz gebremst)
ausgeführt wird. Auf die Zeropage-Register wird ohnehin immer ungebremst
zugegriffen. Lediglich beim Zugriff auf das Grafik-RAM (das C64-interne) zwecks
Manipulation der Grafikdaten, erfolgt der Zugriff nur mit 1 MHz, was aber anteilig
eher geringfügig ist.
Allerdings hat der Modus "vollständige ROM-Simulation" den Nachteil, dass ab
$8000 das externe RAM eingeblendet ist und als Pseudo-ROM wie ein ROM nicht 
veränderlich ist. Hier funktioniert leider auch nicht die gewohnte Steuerung 
der Memory-Map mittels Prozessorport $01. Daher muss beim Zugriff auf das 
Grafik-RAM ab $E000 immer dieser Modus ausgeschaltet und auf die normale 
ROM-Simulation umgeschaltet werden (wo dann das KERNAL-ROM ausgeblendet ist).
Diese Umschaltung ist nur in der speziellen graext-c000-ltc-Variante
inkludiert. Da hierbei umständlich ein Konfigurationsregister der HW-Erweiterung
beschrieben werden muss, kommen hier zur Sicherung des Registers und zum Erreichen
des Konfigurationsregisters auch 65816er-Befehle vor, die aber auch im
Emulationsmodus ausgeführt werden können (XBA, STA absolut-long).
Dieser zusätzliche Code hat als Nebenwirkung ein leichte Verlangsamung
im 1-MHz-Modus im Vergleich zum "normalen" C64 ohne HW-Erweiterung, aber im
Turbo-Modus wird das Maximum der möglichen Geschwindigkeit heraus geholt.



Benchmarking
-------------

++++++++ GraExt 1.17

### Dreieck

10 &g,1,5,0
20 &s,2
100 fori=0to319
110 &l,0,0,i,199
120 next
130 goto100
1000 &g,0

# 6510 1 MHz
10 Durchläufe 1:33 -> 9,3s


+++++++ GraExt 1.25

### Unterschied &H im Blockmodus und &V


# Vertikale Linie von links nach rechts den Bildschirm füllend.
# Siehe demo-h-v.bas


# Variante 1 (1 320 lange und 200 breite horzontale Linie)
&H 0,0,319,199

# Variante 2 (320 1 Pixel lange horizontale Linie vertikal über volle Höhe)
FOR X=0TO319
&H X,0,0,199
NEXT

# Variante 3 (320 vertikale Linien)
FOR X=0TO319
&V X,0,199
NEXT

# Variante 4 (320 vertikale Linien, ist Sonderfall der auf &V-Routine geht)
FOR X=0TO319
&L X,0,X,199
NEXT

# Variante 5 (200 horizontale 320 lange Linien, ist Sonderfall der auf &H-Routine geht)
FOR X=0TO199
&L 0,X,319,X
NEXT


Variante	Zeit
1: &H full	0,03
2: &H		6,52
3: &V		5,45
4: &L vert.	5,83
5: &L hor.	2,50



++++++++++ GraExt 1.26 - 1.27

# Bildschirm mit vertikalen Linien füllen.
# Siehe demo-h-v.bas


10x &VX,0,199           54.25 s (TI)

Nach &V Optimierung in 1.27

10x &VX,0,199           52.85 s (TI)
10x &VX,199,X,0         57.00 s (TI)    Parsing 4. Parameter
10x &VX,0,X,199         57.05 s (TI)    Parsing 4. Parameter und Tausch der Y-Werte

