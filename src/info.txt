GRA-EXT
=======

Autor: Johann Klasek, johann AT klasek at


Versionen:

	2016-06-19 v 1.25		&C korrigiert umstrukturiert.
					&s5 ist noch nicht implementiert.
					Produktiv mit Mängel:
					Fehlerbehandlung unvollständig (für &s3-5)
					Neu: &H x,y,xl[,yl] (breite horiz.  Linie)
					LTC-Variante berücksichtigt spezielle
					Speicherkonfiguration!
					Versionsnummer im Dateikopf.
	2016-06-16 v 1.24		Bugfix: &C korrigiert umstrukturiert.
					Startmeldung nur im Direktmodus ausgeben.
					Buggy:
					&s3-5 funktioniert nicht.
					Fehlerbehandlung unvollständig (für &s3-5)
	2016-05-30 v 1.23		&U neu (UNNEW)
					Buggy:
					&s3-5 funktioniert nicht.
					Fehlerbehandlung unvollständig (für &s3-5)
	2016-05-20 v 1.22		&G Modi 3 (nur löschen) und 4 (nur aus)
					&S neue Werte 3-5 für Fehlerbehandlung,
					Fehlerbehandlung dynamisch (unvollständig)
					ROM-fähig (gmask, gchange Routinen ins
					RAM, $033C-Bereich)
					Buggy:
					&s3-5 funktioniert nicht.
					Fehlerbehandlung unvollständig (für &s3-5)
	2016-02-23 v 1.21		graext-core.asm als Basis für
					graext (ge) und ge-run (als
					RUN-Programm, verschiebt Basic-Start!)
	2016-02-23 v 1.20		Optimierte Jump-Table, Bugfix Line
					command_rts_style=1 ... Kommandoverteiler
					via RTS statt JMP.
					Bugfix Command-Hook: z.B. ":" am
					Zeilenanfang lösten einen Syntax-Error aus.
	2016-01-18 v 1.19               Bug in Line flat/up
					no_error=1 ... kein Illegal Quantity Error
	2016-01-14 v 1.18		in ACME-Source übertragen
					Binär dem Original 1992 entsprechend,
					inklusive aller Bugs.
	1992-12-28 v 1.18		Kommandosyntax ohne ","
					Verteils (z.B. an Michael Rautner)
	1986-03-24 v 1.17		Finale Version
					zur damaligen Zeit üblicherweise
					in Verwendung (Maturazeitungsdiagramme)
	1985       v 0.00 - 1.16


ToDo:

 behoben:
 * &C Prozport nicht mit festen Wert überschreiben ($21), nur maskieren! -> ab 1.24


Wunschliste:

 * Block gefüllt (&H anpassen?)
 * Fehlerbehandlung auswählbar.
 * Grafikcursor auslesen.
 * GETXY-Funktion
 * Fill
 * Grafik löschen separat und besonders schnell!
 * Optimierungen: Line, zu niedrigen Koordinaten mit
        Dekremetieren und Zero-Bedingung statt Inkremtieren
        mit explizitem Vergleich.
 * Circle
 * Clipping: trotzdem Zeichnen, aber am Rand aufhören.
        Echtes Clipping oder nur Koordinaten abschneiden?
 * Multicolor?

erledigt:
 * Unnew -> ab 1.23
 * Grafik einschalten ohne löschen. -> ab 1.22


Geschichte:

Die Wurzeln der Erweiterung liegen bei der Grafikerweiterung für die
Forth-Umgebung Performance Micro Prod. von Greg Harris. Die im (eigenen)
Forth-Assembler codierten Routinen sind dahingehend optimiert, dass die
auf dem Bresenham-Algorithmus basierende Umsetzung ohne ständige
Punktpositionsberechung arbeitet, sondern der Grafikcursor als Adresse
und Bitposition geführt wird.
Ein gleichwertige Implementierung findet man auch im Spiel Elite, wobei dort
der Grafikbereich so eingeschränkt ist, dass die X-Koordinate mit einem Byte
auskommt (0-255), was eine noch schnellere Implementierung erlaubt.
Dazu kamen auch noch speziell optimiert Varianten für eine horizontale
und vertikale Linie, die auch als Sonderfall beim gewöhnlichen Linienbefehl
Verwendung finden.

Eine Verwendung für BASIC war wegen der Akzeptanz dringend notwendig,
was zur Entwicklung einer entsprechenden BASIC-Erweiterung führte. Das
genaue Zustandekommen der Übertragung aus dem Forth-Code ist nicht mehr
nachvollziehbar, da entsprechende Aufzeichnung fehlen. Vermutet werden
kann, dass Code entweder 1:1 herauskopiert wurde und dabei mit
Hilfe eines Monitors der Code verschoben und dessen absoluten Referenzen
und Zeropage-Adressen automatisch angepasst wurden. Der Glue-Code für den
Basic-Interpreter wurde direkt mit einem Monitor assembliert und
schließlich ohne eigentlichem Sourcecode abgespeichert.
Oder es wurde ein Assembler-Source vom Forth-Source konvertiert und
dann mit dem Glue-Code versehen. Der Source-Code ist aber nicht mehr
auffindbar, der diese Variante hätte belegen können.

Dabei ist der Code für den Punkttest (unter Forth "TEST") zwar enthalten,
wird aber vom Glue-Code nicht in den Interpreter eingebunden.


Verwendung
----------


### RUN-Variante

LOAD"GE-RUN",8
RUN

# Einschaltmeldung sollte erscheinen.

LOAD"....",8



### SYS-Variante

LOAD"GE",8,1
NEW
LOAD"....",8

1 IFPEEK(49153)+PEEK(49154)=21THENSYS49152



### Originalvariante

LOAD"G-EXT18",8,1
NEW
LOAD"....",8

1 SYS49152




Source
------


Makefile		Erstellen von
			make
				erstellt Gra-Ext PRGs
			make i
				erstellt D64-Image x.d64

debug.bas		Grafik-Demo: Block-/Linien-Demo
				zum Experimentieren (Textformat)
debug.prg		Grafik-Demo: Block-/Linien-Demo
				zum Experimentieren (CBM-Format)

demo1.bas		Grafik-Demo: Schirm mit Linien füllen (Textformat)
demo1.prg		Grafik-Demo: Schirm mit Linien füllen (CBM-Format)

demo2.bas		Grafik-Demo: Schirm mit mittigem Linienstrahlen füllen (Textformat)
demo2.prg		Grafik-Demo: Schirm mit mittigem Linienstrahlen füllen (CBM-Format)

demo-h-v.bas		Grafik-Demo: Vergleich Schirmfüllen mit
			H-Linien, V-Linien und H-Block (Textformat)
demo-h-v.prg		Grafik-Demo: Vergleich Schirmfüllen mit
			H-Linien, V-Linien und H-Block (CBM-Format)

g-ext18.hex		Gra-Ext 1.8 im od-Hex-Format
g-ext18.prg		Gra-Ext 1.8 im CBM-Format als Referenz, von der
			Distributionsdisk

gliding-lines.bas	Grafik-Demo: Bewegendes Linienbündel (Textformat)
gliding-lines.prg	Grafik-Demo: Bewegendes Linienbündel (CBM-Format)

ge-run.asm		Gra-Ext RUN-Variante, verwendet graext-core.asm
ge-run.l		ACME Listing-Ausgabe der RUN-Variante
ge-run.prg		ACME Objekt-Datei (CBM-Format) der RUN-Variante
ge-run.r		ACME Report-Ausgabe der RUN-Variante

graext-c000-ltc		Gra-Ext LTC-Variante (Lost Turbo Card 64)
graext-c000-ltc.l	ACME Listing-Ausgabe der LTC-Variante
graext-c000-ltc.r	ACME Report-Ausgabe der LTC-Variante

graext-core.asm		Gra-Ext Core für RUN-Variante, SYS-Variante

graext.asm		Gra-Ext SYS-Variante, verwendet graext-core.asm

graext.hex		Binary im Hex-Format für den diff-Vergleich
			mit der Referenz g-ext18.hex
			War nur für die Source-Wiederherstellung
			auf Basis des 1.8-Codes verwendet worden.

ge.prg			Nur eine Kopie von graext.o, für das D64-Image

graext.l		ACME Listing-Ausgabe der SYS-Variante
graext.o		ACME Objekt-Datei (CBM-Format) der SYS-Variante
graext.r		ACME Report-Ausgabe der SYS-Variante

info.txt		diese Datei

x.d64			D64-Image, erstell mittels
			make x.d64
			oder
			make i





Benchmarking
-------------

++++++++ GraExt 1.17

### Dreieck

10 &g,1,5,0
20 &s,2
100 fori=0to319
110 &l,0,0,i,199
120 next
130 goto100
1000 &g,0

# 6510 1 MHz
10 Durchläufe 1:33 -> 9,3s


+++++++ GraExt 1.25

### Unterschied &H im Blockmodus und &V

# Vertikale Linie von links nach rechts den Bildschirm füllend.
# Siehe demo-h-v.bas

# Variante 1
&H 0,0,319,199

# Variante 2 (1 Pixel lange vertikale Linie vertikal über volle Höhe)
FOR X=0TO319
&H X,0,0,199
NEXT

# Variante 3
FOR X=0TO319
&V X,0,199
NEXT

# Variante 4 (vertikale Linie, ist Sonderfall der auf &V-Routine geht)
FOR X=0TO319
&L X,0,X,199
NEXT

# Variante 5 (vergleich, mit horiz. Linien füllen)
FOR X=0TO199
&L 0,X,319,X
NEXT


Variante	Zeit
1: &H full	0,03
2: &H		6,52
3: &V		5,45
4: &L vert.	5,83
5: &L hor.	2,50


